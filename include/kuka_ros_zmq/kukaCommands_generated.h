// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_KUKACOMMANDS_ROS_KUKA_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_KUKACOMMANDS_ROS_KUKA_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace ros_kuka {
namespace flatbuffer {

struct Vector3;

struct Quaternion;

struct RPY;

struct kukaDesPose;

enum ControlMode {
  ControlMode_BackHome = 0,
  ControlMode_Joints = 1,
  ControlMode_CartesianPTP = 2,
  ControlMode_CartesianSS = 3,
  ControlMode_CartesianDS = 4,
  ControlMode_MIN = ControlMode_BackHome,
  ControlMode_MAX = ControlMode_CartesianDS
};

inline const char **EnumNamesControlMode() {
  static const char *names[] = { "BackHome", "Joints", "CartesianPTP", "CartesianSS", "CartesianDS", nullptr };
  return names;
}

inline const char *EnumNameControlMode(ControlMode e) { return EnumNamesControlMode()[static_cast<int>(e)]; }

MANUALLY_ALIGNED_STRUCT(8) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  Vector3(double _x, double _y, double _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vector3, 24);

MANUALLY_ALIGNED_STRUCT(8) Quaternion FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;
  double w_;

 public:
  Quaternion(double _x, double _y, double _z, double _w)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)), w_(flatbuffers::EndianScalar(_w)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
  double w() const { return flatbuffers::EndianScalar(w_); }
};
STRUCT_END(Quaternion, 32);

MANUALLY_ALIGNED_STRUCT(8) RPY FLATBUFFERS_FINAL_CLASS {
 private:
  double alpha_;
  double beta_;
  double gamma_;

 public:
  RPY(double _alpha, double _beta, double _gamma)
    : alpha_(flatbuffers::EndianScalar(_alpha)), beta_(flatbuffers::EndianScalar(_beta)), gamma_(flatbuffers::EndianScalar(_gamma)) { }

  double alpha() const { return flatbuffers::EndianScalar(alpha_); }
  double beta() const { return flatbuffers::EndianScalar(beta_); }
  double gamma() const { return flatbuffers::EndianScalar(gamma_); }
};
STRUCT_END(RPY, 24);

struct kukaDesPose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION = 4,
    VT_ORIENTATION = 6,
    VT_ROTATION = 8,
    VT_CONTROL = 10,
    VT_JOINTS = 12
  };
  const Vector3 *position() const { return GetStruct<const Vector3 *>(VT_POSITION); }
  const Quaternion *orientation() const { return GetStruct<const Quaternion *>(VT_ORIENTATION); }
  const RPY *rotation() const { return GetStruct<const RPY *>(VT_ROTATION); }
  ControlMode control() const { return static_cast<ControlMode>(GetField<int8_t>(VT_CONTROL, 1)); }
  const flatbuffers::Vector<double> *joints() const { return GetPointer<const flatbuffers::Vector<double> *>(VT_JOINTS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3>(verifier, VT_POSITION) &&
           VerifyField<Quaternion>(verifier, VT_ORIENTATION) &&
           VerifyField<RPY>(verifier, VT_ROTATION) &&
           VerifyField<int8_t>(verifier, VT_CONTROL) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_JOINTS) &&
           verifier.Verify(joints()) &&
           verifier.EndTable();
  }
};

struct kukaDesPoseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const Vector3 *position) { fbb_.AddStruct(kukaDesPose::VT_POSITION, position); }
  void add_orientation(const Quaternion *orientation) { fbb_.AddStruct(kukaDesPose::VT_ORIENTATION, orientation); }
  void add_rotation(const RPY *rotation) { fbb_.AddStruct(kukaDesPose::VT_ROTATION, rotation); }
  void add_control(ControlMode control) { fbb_.AddElement<int8_t>(kukaDesPose::VT_CONTROL, static_cast<int8_t>(control), 1); }
  void add_joints(flatbuffers::Offset<flatbuffers::Vector<double>> joints) { fbb_.AddOffset(kukaDesPose::VT_JOINTS, joints); }
  kukaDesPoseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  kukaDesPoseBuilder &operator=(const kukaDesPoseBuilder &);
  flatbuffers::Offset<kukaDesPose> Finish() {
    auto o = flatbuffers::Offset<kukaDesPose>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<kukaDesPose> CreatekukaDesPose(flatbuffers::FlatBufferBuilder &_fbb,
   const Vector3 *position = 0,
   const Quaternion *orientation = 0,
   const RPY *rotation = 0,
   ControlMode control = ControlMode_Joints,
   flatbuffers::Offset<flatbuffers::Vector<double>> joints = 0) {
  kukaDesPoseBuilder builder_(_fbb);
  builder_.add_joints(joints);
  builder_.add_rotation(rotation);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add_control(control);
  return builder_.Finish();
}

inline const ros_kuka::flatbuffer::kukaDesPose *GetkukaDesPose(const void *buf) { return flatbuffers::GetRoot<ros_kuka::flatbuffer::kukaDesPose>(buf); }

inline bool VerifykukaDesPoseBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<ros_kuka::flatbuffer::kukaDesPose>(); }

inline void FinishkukaDesPoseBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ros_kuka::flatbuffer::kukaDesPose> root) { fbb.Finish(root); }

}  // namespace flatbuffer
}  // namespace ros_kuka

#endif  // FLATBUFFERS_GENERATED_KUKACOMMANDS_ROS_KUKA_FLATBUFFER_H_
